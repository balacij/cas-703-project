\documentclass[11pt,fleqn]{article}

\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{url}

% Allow more line breaks in URLs
\usepackage{xurl}

% Enable links within the document
\usepackage{hyperref}
\usepackage{titlesec}

\usepackage[
  a4paper,
  top=3.8cm,
  bottom=2.5cm,
  inner=2.5cm,
  outer=2.5cm,
  headheight=15pt,
]{geometry}

\hypersetup{
  colorlinks=true,
  linkcolor=red,
  urlcolor=red,
  breaklinks=true,
}
\urlstyle{rm} % Make URL styled fonts match hyperref's hrefs

\usepackage{cleveref}

% Credit to Gabriel Devenyi for this bibliography cfg:
% github.com/gdevenyi/mcmaster.latex
\usepackage[
  style=numeric-comp,
  backend=biber,
  sorting=none,
  backref=true,
  maxnames=99,
  alldates=iso,
  seconds=true
]{biblatex} % bibliography
\addbibresource{references.bib}

% Soure code
\usepackage{listings}

\Crefname{lstlisting}{Listing}{Listings}

\lstdefinestyle{mystyle}{
  basicstyle=\ttfamily\footnotesize,
  tabsize=2
}
\lstset{style=mystyle}

\title{\vspace{-3.5cm}CAS 703 Term Project: Validated General-Purpose Calculators}
\author{Hassan Zaker \and Jason Balaci}

\date{
	McMaster University \\ \texttt{\{zakerzah, balacij\}@mcmaster.ca}\\%
	\today
}

\usepackage{multicol}
\usepackage{todonotes}

\begin{document}

\maketitle

\tableofcontents

\lstlistoflistings

\newpage{}

%------------------------------------------------------------------------------
% Introduction
%------------------------------------------------------------------------------
\section{Introduction}
\label{sec:introduction}

For our term project in CAS 703~\cite{Paige7032023}, we decided to build a
language for describing calculation schemes. The descriptions should be mostly
understandable to anyone who has worked with Excel~\cite{Excel} or has used any
kind of calculation software. We aim to validate the
coherence\footnote{``Coherence'' defined by an unambiguous set of constraints
and rules.} of the calculator descriptions. Additionally, through generative
techniques, we hope to decrease the barrier to entry (as much as we can) of
basic software development of calculator programs by defining a transformation
of the calculator descriptions to various programming
languages\footnote{Notably, Java programs.}.

\subsection{Objective}

We aim to:

\begin{enumerate}

  \item design a metamodel for describing calculator programs
        (\Cref{sec:modelling}),

  \item build a concrete syntax for the metamodel, and an Integrated Development
        Environment (IDE) for said concrete syntax
        (\Cref{sec:integrated-development-environment}),

  \item design a set of rules that define ``coherence'' rules of the metamodel
        and audit instances of the metamodel for coherence
        (\Cref{sec:model-validation}), and

  \item define a transformer that converts the calculator description into
        programs and corresponding documentation
        (\Cref{sec:model-management-operations}).

\end{enumerate}

\subsection{Tooling}

We will use the tooling shown in 703, namely: Eclipse Epsilon~\cite{Epsilon} and
the languages it contains, and Xtext~\cite{Xtext}.

\newpage{}

%------------------------------------------------------------------------------
% Modelling
%------------------------------------------------------------------------------
\section{Modelling}
\label{sec:modelling}

To define our metamodel for our desired Domain-Specific Language (DSL), we first
need to iron out the \textit{requirements} of that language.

\subsection{Requirements}
\label{sec:modelling:subsec:requirements}

When we (the authors) think of ``calculators,'' we think of 3 main components:
(i) a set of input symbols, (ii) a set of output symbols, and (iii) a means of
deriving the output symbols from the input symbols. (i) and (ii) are really just
``symbols'' with designation of whether they are user-provided or calculated.
(iii) is a (commonly secret) algorithm that translates (i) to (ii) and which may
rely on intermediate symbols irrelevant to (i) and (ii). Thus, we think of a
calculator as being a structure of (a) symbols of different kinds (inputs,
intermediates, and outputs) and (b) an algorithm that calculates some symbols
from an initial subset of provided symbols.

Depending on your preferred school of thought, algorithms can be thought of
differently. We choose to think of them as being similar to imperative-style
programming languages, where there is a memory of symbols to values, and a
sequence of steps/statements that are executed sequentially against the memory.

The most important kind of ``step'' our algorithm must have is ``symbol
assignment,'' where some symbol is assigned the value of some expression. The
expression may contain other symbols, but it should be restricted to only using
symbols that have been assigned values (either as input to the calculator or by
an earlier step). Logging is another important kind of step that algorithms
might need, they're typically used for providing user-feedback for debugging,
general information, warnings, errors, etc. Logging, similar to assignment
steps, are provided an expression, for which are evaluated, but the difference
is that the logging step displays the value to the user-feedback mechanism of
the calculator rather than assigning the value to a symbol. For now, we choose
to think of calculators as only having these 2 kinds of steps.

The steps rely on a single mathematical expression language that describes how
values can be altered in a predictable way. We choose to restrict our expression
language to the common first-order definite-valued mathematical language that
most undergraduates in a first-year university mathematics class are familiar
with.

Similar to how we expect our expression language to provide predictable results,
we also expect our calculators to be predictable and reliably produce accurate
results. To gain confidence in accuracy and predictability, we can test our
calculators against well-known outputs for well-known inputs. In other words, we
can create test cases to gain confidence that our calculator is reliable (which
we want to reasonably assure ourselves).

Thus, together, we define our calculator as having 3 main aspects: (a) a set of
symbols, (b) an algorithm that somehow calculates the output symbols from the
inputs, and (c) a set of test cases to gain confidence that (b) is reliable. To
model our calculator DSL, we chose to use Emfatic (EMF) because we found it to
be faster to work with. In particular, we found it to be more readable and
easier to modify compared to Ecore.

\subsection{Emfatic}
\label{sec:modelling:subsec:emfatic}

\begin{lstlisting}[caption={Calculator EMF},label={lst:calculator}]
class Calculator extends Described {
  attr String[1] name = "";
	val SymbolDeclaration[*] symbolDeclarations;
	val CalculationStep[*] steps;
	val TestCase[*] testCases;
}
\end{lstlisting}

When translating the calculators to Emfatic (\Cref{lst:calculator}), we also
added the name and a description of the calculators using string
attributes\footnote{Note that since we commonly use comments and descriptions,
we added a ``Described'' base class to quickly attach description attributes
(\Cref{lst:described}).}. The calculator class contains 3 other ``containment
references'' (\lstinline{val}s): symbol declarations, calculation steps
(denoting the algorithm), and a set of test cases.

Symbol declarations (\lstinline{SymbolDeclaration},
\Cref{lst:symbol-declarations}) define a symbol (\lstinline{Symbol}) with a
textual description and the \textit{kind} of symbol it is \textemdash{} input
(user-provided at the start of the calculator), intermediate (derived from the
inputs but not important), or output symbols (symbols that users are interested
in calculating). Since the difference between the symbol kinds is quite surface
level (or so we claim), we chose to use an \lstinline{enum} attribute in our
symbol declaration type. If there were any behavioural differences, we would
have used a subclass. The symbol content itself is contained in another class
(\lstinline{Symbol}) with a one-to-one relationship with symbol declarations.
\lstinline{Symbol}s contain a name attribute (assumed to be a Java-friendly
identifier) and a declared \textit{type} of the symbol. The types are
containment references of \lstinline{Type}s (\Cref{lst:type-universe}).  

We chose to build a basic unambiguous judgment-based~\cite{nlab:judgment} type
system. We restricted our type universe in our calculator to ``simple''
first-order types with no parameters. Thus, we have booleans, strings, integers,
and real numbers. However, we do intend to implement vectors as well. We used an
abstract \lstinline{Type} class to create a generic class of types (with basic
feature requirements), and then a subclass (\lstinline{PrimitiveType}) to
designate primitive types using an enumeration of primitive types
(\lstinline{Primitive}). By extending the basic \lstinline{Type} class with
other types, we can further extend our DSLs type system.

The next major component of our calculators are the calculation steps. As
already mentioned in \Cref{sec:modelling:subsec:requirements}, we restricted
ourselves to 2 kinds of steps: assignment steps, and print steps. Assignment
steps (\lstinline{AssignmentStep}) and print steps (\lstinline{PrintStep}) are
both subclasses of the abstract base class: \lstinline{CalculationStep}
(\Cref{lst:calculation-steps}). Print steps contain a description (we called it
a ``preface'') for the need to print a particular symbol (noted by reference).
\lstinline{AssignmentStep}s contain a reference to a symbol, an optional
description \lstinline{String} attribute, and a value reference to a defining
expression. The expression is expected to be well-typed, but we only impose this
restriction in \Cref{sec:model-validation}.

Expressions have a shared base class: \lstinline{Expression}
(\Cref{lst:expression-language}). There are various kinds of expressions we've
implemented, such as literals (\lstinline{TextLiteral},
\lstinline{BooleanLiteral}, \lstinline{IntegerLiteral},
\lstinline{RealLiteral}), symbol references (\lstinline{SymbolExpression}),
unary expressions (\lstinline{UnaryExpression}), binary expressions
(\lstinline{BinaryExpression}), and tertiary expressions
(\lstinline{TertiaryExpression}). The \lstinline{Expression} abstract base class
defines a basic functionality set that each subclass of expression must provide
\textemdash{} namely printing, type inference, symbols it depends on, and a Java
representation method.

The last component of our calculators are test cases. We expect that instances
of these calculators to obey a set of test cases. Our \lstinline{TestCase} class
is defined with a name and description String attributes, a list of assignment
steps (that are expected to reference no symbols in their expressions), and a
list of boolean-typed expressions\footnote{Both restrictions are only imposed in
\Cref{sec:model-validation}.}.

Finally, these 3 important classes define our calculators, and we may continue
to our next project: building a concrete syntax for our DSL.

\newpage{}

%------------------------------------------------------------------------------
% IDE
%------------------------------------------------------------------------------
\section{Integrated Development Environment}
\label{sec:integrated-development-environment}

\newpage{}

%------------------------------------------------------------------------------
% Model Validation
%------------------------------------------------------------------------------
\section{Model Validation}
\label{sec:model-validation}

\newpage{}

%------------------------------------------------------------------------------
% Model Management Operations
%------------------------------------------------------------------------------
\section{Model Management Operations}
\label{sec:model-management-operations}

\newpage{}

%------------------------------------------------------------------------------
% Reflection and Concluding Thoughts
%------------------------------------------------------------------------------
\section{Reflection and Concluding Thoughts}
\label{sec:reflection-and-concluding-thoughts}

\newpage{}

%------------------------------------------------------------------------------
% Bibliography
%------------------------------------------------------------------------------
\printbibliography[heading=bibintoc]

\newpage{}

\section*{Appendix}
\addcontentsline{toc}{section}{Appendix}
\label{sec:appendix}

\begin{lstlisting}[caption={Abstract Class: Described},label={lst:described}]
abstract class Described {
  attr String[1] description = "";
}
\end{lstlisting}

\begin{lstlisting}[caption={Symbol Declarations},label={lst:symbol-declarations}]
class SymbolDeclaration extends Described {
  attr SymbolDeclarationKind[1] kind;
  val Symbol[1]#declaration symbol;
}

enum SymbolDeclarationKind {
  INPUT;
  INTERMEDIATE;
  OUTPUT;
}

class Symbol {
  id attr String[1] name = "";
  val Type[1] type;
  ref SymbolDeclaration[1]#symbol declaration;
}
\end{lstlisting}

\begin{lstlisting}[caption={Calculation Steps},label={lst:calculation-steps}]
abstract class CalculationStep extends Described {
	op String[1] toHRN();
	op Symbol[*] dependencies();
	op Symbol[*] calculates();
	op String[1] toJava();
}

class AssignmentStep extends CalculationStep {
	ref Symbol[1] symbol; // LHS
	val Expression[1] body; // RHS
}

class PrintStep extends CalculationStep {
	attr String[1] preface = "";
	ref Symbol[1] symbol;
}
\end{lstlisting}

\begin{lstlisting}[caption={Test Case},label={lst:test-case}]
class TestCase extends Described {
	attr String[1] name = "";
	val AssignmentStep[+] assignments;
	val Expression[+] assertions;
}
\end{lstlisting}

\begin{lstlisting}[caption={Type Universe},label={lst:type-universe}]
enum Primitive {
	TEXT;
	REAL;
	INTEGER;
	BOOLEAN;
}

abstract class Type {
  op String[1] serialize();
  op boolean[1] isNumeric();
	op String[1] toJavaType();
}

class PrimitiveType extends Type {
  attr Primitive[1] primitive;
}

class InvalidType extends Type {
  attr String[1] cause;
}
\end{lstlisting}

\begin{lstlisting}[caption={Expression Language},label={lst:expression-language}]
abstract class Expression {
	op Type[1] type();
	op String[1] toHRN();
	op Symbol[*] symbolReferences();
	op String[1] toJava();
}

class TextLiteral extends Expression {
	attr String[1] value;
}

class RealLiteral extends Expression {
	attr double[1] value;
}

class IntegerLiteral extends Expression {
	attr int[1] value;
}

class BooleanLiteral extends Expression {
	attr boolean[1] value;
}

class SymbolExpression extends Expression {
    ref Symbol[1] symbol;
}

enum UnaryOp {
	LOGICAL_NOT;
	NEGATION;
}

class UnaryExpression extends Expression {
	attr UnaryOp[1] operator;
	val Expression[1] body;
}

enum BinaryOp {
	// numbers (of same type)
	ADDITION; // also allowed for text and vectors
	MULTIPLICATION;
	DIVISION;
	SUBTRACTION;
	POWER;
	MODULO;

	// inequalities
	GREATER_THAN;
	GREATER_THAN_EQUAL_TO;
	LESS_THAN;
	LESS_THAN_EQUAL_TO;
	
	// booleans
	LOGICAL_AND;
	LOGICAL_OR;
	LOGICAL_IMPLIES;
	
	// any
	EQUIVALENT;
	NOT_EQUIVALENT;
}

class BinaryExpression extends Expression {
  attr BinaryOp[1] operator;
  val Expression[2] exprs;
}

enum TertiaryOp {
  IF_THEN_ELSE;
}

class TertiaryExpression extends Expression {
  attr TertiaryOp[1] operator;
  val Expression[3] exprs;
}
\end{lstlisting}

\end{document}
