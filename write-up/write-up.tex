\documentclass[11pt,fleqn]{article}

\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{url}

% Allow more line breaks in URLs
\usepackage{xurl}

% Enable links within the document
\usepackage{hyperref}
\usepackage{titlesec}

\usepackage[
  a4paper,
  top=3.8cm,
  bottom=2.5cm,
  inner=2.5cm,
  outer=2.5cm,
  headheight=15pt,
]{geometry}

\hypersetup{
  colorlinks=true,
  linkcolor=red,
  urlcolor=red,
  breaklinks=true,
}
\urlstyle{rm} % Make URL styled fonts match hyperref's hrefs

\usepackage{cleveref}

% Credit to Gabriel Devenyi for this bibliography cfg:
% github.com/gdevenyi/mcmaster.latex
\usepackage[
  style=numeric-comp,
  backend=biber,
  sorting=none,
  backref=true,
  maxnames=99,
  alldates=iso,
  seconds=true
]{biblatex} % bibliography
\addbibresource{references.bib}

% Soure code
\usepackage{listings}

\Crefname{lstlisting}{Listing}{Listings}

\lstdefinestyle{mystyle}{
  basicstyle=\ttfamily\footnotesize,
  tabsize=2,
  columns=fullflexible,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}
\lstset{style=mystyle}

\title{\vspace{-3.5cm}CAS 703 Term Project: Validated General-Purpose Calculators}
\author{Hassan Zaker \and Jason Balaci}

\date{
	McMaster University \\ \texttt{\{zakerzah, balacij\}@mcmaster.ca}\\%
	\today
}

\usepackage{multicol}
\usepackage{todonotes}

\begin{document}

\maketitle

\tableofcontents

\lstlistoflistings

\newpage{}

%------------------------------------------------------------------------------
% Introduction
%------------------------------------------------------------------------------
\section{Introduction}
\label{sec:introduction}

For our term project in CAS 703~\cite{Paige7032023}, we decided to build a
language for describing calculation schemes. The descriptions should be mostly
understandable to anyone who has worked with Excel~\cite{Excel} or has used any
kind of calculation software. We aim to validate the
coherence\footnote{``Coherence'' defined by an unambiguous set of constraints
and rules.} of the calculator descriptions. Additionally, through generative
techniques, we hope to decrease the barrier to entry (as much as we can) of
basic software development of calculator programs by defining a transformation
of the calculator descriptions to various programming
languages\footnote{Notably, Java programs.}.

\subsection{Objective}

We aim to:

\begin{enumerate}

  \item design a metamodel for describing calculator programs
        (\Cref{sec:modelling}),

  \item build a concrete syntax for the metamodel, and an Integrated Development
        Environment (IDE) for said concrete syntax
        (\Cref{sec:integrated-development-environment}),

  \item design a set of rules that define ``coherence'' rules of the metamodel
        and audit instances of the metamodel for coherence
        (\Cref{sec:model-validation}), and

  \item define a transformer that converts the calculator description into
        programs and corresponding documentation
        (\Cref{sec:model-management-operations}).

\end{enumerate}

\subsection{Tooling}

We will use the tooling shown in 703, namely: Eclipse Epsilon~\cite{Epsilon} and
the languages it contains, and Xtext~\cite{Xtext}.

\newpage{}

%------------------------------------------------------------------------------
% Modelling
%------------------------------------------------------------------------------
\section{Modelling}
\label{sec:modelling}

To define our metamodel for our desired Domain-Specific Language (DSL), we first
need to iron out the \textit{requirements} of that language.

\subsection{Requirements}
\label{sec:modelling:subsec:requirements}

When we (the authors) think of ``calculators,'' we think of 3 main components:
(i) a set of input symbols, (ii) a set of output symbols, and (iii) a means of
deriving the output symbols from the input symbols. (i) and (ii) are really just
``symbols'' with designation of whether they are user-provided or calculated.
(iii) is a (commonly secret) algorithm that translates (i) to (ii) and which may
rely on intermediate symbols irrelevant to (i) and (ii). Thus, we think of a
calculator as being a structure of (a) symbols of different kinds (inputs,
intermediates, and outputs) and (b) an algorithm that calculates some symbols
from an initial subset of provided symbols.

Depending on your preferred school of thought, algorithms can be thought of
differently. We choose to think of them as being similar to imperative-style
programming languages, where there is a memory of symbols to values, and a
sequence of steps/statements that are executed sequentially against the memory.

The most important kind of ``step'' our algorithm must have is ``symbol
assignment,'' where some symbol is assigned the value of some expression. The
expression may contain other symbols, but it should be restricted to only using
symbols that have been assigned values (either as input to the calculator or by
an earlier step). Logging is another important kind of step that algorithms
might need, they're typically used for providing user-feedback for debugging,
general information, warnings, errors, etc. Logging, similar to assignment
steps, are provided an expression, for which are evaluated, but the difference
is that the logging step displays the value to the user-feedback mechanism of
the calculator rather than assigning the value to a symbol. For now, we choose
to think of calculators as only having these 2 kinds of steps.

The steps rely on a single mathematical expression language that describes how
values can be altered in a predictable way. We choose to restrict our expression
language to the common first-order definite-valued mathematical language that
most undergraduates in a first-year university mathematics class are familiar
with.

Similar to how we expect our expression language to provide predictable results,
we also expect our calculators to be predictable and reliably produce accurate
results. To gain confidence in accuracy and predictability, we can test our
calculators against well-known outputs for well-known inputs. In other words, we
can create test cases to gain confidence that our calculator is reliable (which
we want to reasonably assure ourselves).

Thus, together, we define our calculator as having 3 main aspects: (a) a set of
symbols, (b) an algorithm that somehow calculates the output symbols from the
inputs, and (c) a set of test cases to gain confidence that (b) is reliable. To
model our calculator DSL, we chose to use Emfatic (EMF) because we found it to
be faster to work with. In particular, we found it to be more readable and
easier to modify compared to Ecore.

\subsection{Emfatic}
\label{sec:modelling:subsec:emfatic}

\begin{lstlisting}[caption={Calculator EMF},label={lst:calculator}]
class Calculator extends Described {
  attr String[1] name = "";
	val SymbolDeclaration[*] symbolDeclarations;
	val CalculationStep[*] steps;
	val TestCase[*] testCases;
}
\end{lstlisting}

When translating the calculators to Emfatic (\Cref{lst:calculator}), we also
added the name and a description of the calculators using string
attributes\footnote{Note that since we commonly use comments and descriptions,
we added a ``Described'' base class to quickly attach description attributes
(\Cref{lst:described}).}. The calculator class contains 3 other ``containment
references'' (\lstinline{val}s): symbol declarations, calculation steps
(denoting the algorithm), and a set of test cases.

Symbol declarations (\lstinline{SymbolDeclaration},
\Cref{lst:symbol-declarations}) define a symbol (\lstinline{Symbol}) with a
textual description and the \textit{kind} of symbol it is \textemdash{} input
(user-provided at the start of the calculator), intermediate (derived from the
inputs but not important), or output symbols (symbols that users are interested
in calculating). Since the difference between the symbol kinds is quite surface
level (or so we claim), we chose to use an \lstinline{enum} attribute in our
symbol declaration type. If there were any behavioural differences, we would
have used a subclass. The symbol content itself is contained in another class
(\lstinline{Symbol}) with a one-to-one relationship with symbol declarations.
\lstinline{Symbol}s contain a name attribute (assumed to be a Java-friendly
identifier) and a declared \textit{type} of the symbol. The types are
containment references of \lstinline{Type}s (\Cref{lst:type-universe}).  

We chose to build a basic unambiguous, static,
judgment-based~\cite{nlab:judgment} type system. We restricted our type universe
in our calculator to ``simple'' first-order types with no parameters. Thus, we
have booleans, strings, integers, and real numbers. However, we do intend to
implement vectors as well. We used an abstract \lstinline{Type} class to create
a generic class of types (with basic feature requirements), and then a subclass
(\lstinline{PrimitiveType}) to designate primitive types using an enumeration of
primitive types (\lstinline{Primitive}). By extending the basic \lstinline{Type}
class with other types, we can further extend our DSLs type system.

The next major component of our calculators are the calculation steps. As
already mentioned in \Cref{sec:modelling:subsec:requirements}, we restricted
ourselves to 2 kinds of steps: assignment steps, and print steps. Assignment
steps (\lstinline{AssignmentStep}) and print steps (\lstinline{PrintStep}) are
both subclasses of the abstract base class: \lstinline{CalculationStep}
(\Cref{lst:calculation-steps}). Print steps contain a description (we called it
a ``preface'') for the need to print a particular symbol (noted by reference).
\lstinline{AssignmentStep}s contain a reference to a symbol, an optional
description \lstinline{String} attribute, and a value reference to a defining
expression. The expression is expected to be well-typed, but we only impose this
restriction in \Cref{sec:model-validation}.

Expressions have a shared base class: \lstinline{Expression}
(\Cref{lst:expression-language}). There are various kinds of expressions we've
implemented, such as literals (\lstinline{TextLiteral},
\lstinline{BooleanLiteral}, \lstinline{IntegerLiteral},
\lstinline{RealLiteral}), symbol references (\lstinline{SymbolExpression}),
unary expressions (\lstinline{UnaryExpression}), binary expressions
(\lstinline{BinaryExpression}), and tertiary expressions
(\lstinline{TertiaryExpression}). The \lstinline{Expression} abstract base class
defines a basic functionality set that each subclass of expression must provide
\textemdash{} namely printing, type inference, symbols it depends on, and a Java
representation method.

The last component of our calculators are test cases. We expect that instances
of these calculators to obey a set of test cases. Our \lstinline{TestCase} class
is defined with a name and description String attributes, a list of assignment
steps (that are expected to reference no symbols in their expressions), and a
list of boolean-typed expressions\footnote{Both restrictions are only imposed in
\Cref{sec:model-validation}.}.

Finally, these 3 important classes define our calculators, and we may continue
to our next project: building a concrete syntax for our DSL.

\newpage{}

%------------------------------------------------------------------------------
% IDE
%------------------------------------------------------------------------------
\section{Integrated Development Environment}
\label{sec:integrated-development-environment}

\newpage{}

%------------------------------------------------------------------------------
% Model Validation
%------------------------------------------------------------------------------
\section{Model Validation}
\label{sec:model-validation}

Using the Epsilon Validation Language (EVL), we built a series of constraints to
impose restrictions we weren't able to adequately impose through the metamodel
(\Cref{lst:constraints-and-critiques}). In particular, we built a series of
constraints (hard requirements) and critiques (soft requirements/preferences)
for models of our metamodel.

\noindent{}Calculator Constraints:
\begin{enumerate}
  \item \textit{named}: each calculator must have a name for users to
        disambiguate between calculators and their other files,
  \item \textit{unique symbols}: each calculator must have a set of symbols that
        have unique names within that set so variable references can be
        unambiguous,
  \item \textit{at least 1 input}: each calculator should have at least 1 input
        symbol or else there is no interactivity with the calculators generated,
        so a normal calculator should be used instead,
  \item \textit{at least 1 output}: each calculator should have at least 1
        output symbol or else there would be no way to audit or use the
        calculator,
  \item \textit{all outputs assigned once}: all designated output symbols are
        meaningful in some way and should be guaranteed to have a value at the
        end of the calculation steps,
  \item \textit{all intermediate symbols assigned once}: if a declared
        intermediate symbol is never assigned, then it can be removed to
        de-clutter the calculator,
  \item \textit{all assignment steps well-typed}: each assignment should involve
        a symbol of the same type as an expression,
  \item \textit{all test case assignments are input symbols}: the
        pre-calculation state of the calculators should only have input
        variables assigned values,
  \item \textit{all test case assignments contain no variable references}: all
        assignment bodies in test cases should be evaluable to literal-valued
        expressions (e.g., contain no symbol references) because there is no
        defined variables before input set,
  \item \textit{all test cases assign all input variables}: each test case
        should mimic users fully, by providing all necessary inputs the
        calculator would need,
  \item \textit{all test case inputs unambiguous/``no duplicates''}: each
        defined test case should have no ambiguous symbol assignments or else
        the initial state of the test case simulations would be ambiguous,
  \item \textit{all test case assertions are boolean-typed}: the assertions
        should be propositional statements or else they should be part of the
        calculation steps of the main calculator,
  \item \textit{all steps depend on non-null symbols}: each step of the
        calculation should only rely on symbols with defined values or else
        invalid and undefined expressions and operations will occur, and
  \item \textit{all test cases satisfied}: the calculation steps should be
        simulated under each test case, and each test case should be satisfied.
\end{enumerate}

\noindent{}Calculator Critiques:
\begin{enumerate}
  \item \textit{description}: it would be nice to have a description of the
        intent of the calculator and general information about how it works,
  \item \textit{all inputs described}: it would be nice for each input symbol to
        have a user-friendly description to describe what the variable means,
  \item \textit{all outputs described}: same as above, and
  \item \textit{all test case assertions meaningful}: each test case assertion
        statement should reference symbols in that calculator or else the
        assertion would be evaluable without simulation.
\end{enumerate}

\noindent{}Symbol constraints:
\begin{enumerate}
  \item \textit{named}: each symbol should have a name or else using them would
        be impossible, and
  \item \textit{named with only appropriate characters}: a restriction imposed
        by desiring Java-compilation and non-unicode data entry \textemdash{}
        names/identifiers should be usable as Java identifiers.
\end{enumerate}

Finally, we have our last constraint: each expression should be well-typed, or
else invalid states are possible, and we don't want calculators to ever get
``stuck.''

Together, these make up our constraints. We build them using standard EVL
tooling (\Cref{lst:constraints-and-critiques}) and run them using a Gradle
script on our parsed model. If all constraints and critiques are satisfied for a
model, then we claim that the produced artifacts (see
\Cref{sec:model-management-operations}) and the model are relatively
high-quality. Furthermore, we claim that the produced code artifact should be
well-typed, and thus never run into invalid states, errors, or any issue at
runtime (excluding that related to business logic).

\newpage{}

%------------------------------------------------------------------------------
% Model Management Operations
%------------------------------------------------------------------------------
\section{Model Management Operations}
\label{sec:model-management-operations}

\newpage{}

%------------------------------------------------------------------------------
% Reflection and Concluding Thoughts
%------------------------------------------------------------------------------
\section{Reflection and Concluding Thoughts}
\label{sec:reflection-and-concluding-thoughts}

\newpage{}

%------------------------------------------------------------------------------
% Bibliography
%------------------------------------------------------------------------------
\printbibliography[heading=bibintoc]

\newpage{}

\section*{Appendix}
\addcontentsline{toc}{section}{Appendix}
\label{sec:appendix}

\begin{lstlisting}[caption={Abstract Class: Described},label={lst:described}]
abstract class Described {
  attr String[1] description = "";
}
\end{lstlisting}

\begin{lstlisting}[caption={Symbol Declarations},label={lst:symbol-declarations}]
class SymbolDeclaration extends Described {
  attr SymbolDeclarationKind[1] kind;
  val Symbol[1]#declaration symbol;
}

enum SymbolDeclarationKind {
  INPUT;
  INTERMEDIATE;
  OUTPUT;
}

class Symbol {
  id attr String[1] name = "";
  val Type[1] type;
  ref SymbolDeclaration[1]#symbol declaration;
}
\end{lstlisting}

\begin{lstlisting}[caption={Calculation Steps},label={lst:calculation-steps}]
abstract class CalculationStep extends Described {
	op String[1] toHRN();
	op Symbol[*] dependencies();
	op Symbol[*] calculates();
	op String[1] toJava();
}

class AssignmentStep extends CalculationStep {
	ref Symbol[1] symbol; // LHS
	val Expression[1] body; // RHS
}

class PrintStep extends CalculationStep {
	attr String[1] preface = "";
	ref Symbol[1] symbol;
}
\end{lstlisting}

\begin{lstlisting}[caption={Test Case},label={lst:test-case}]
class TestCase extends Described {
	attr String[1] name = "";
	val AssignmentStep[+] assignments;
	val Expression[+] assertions;
}
\end{lstlisting}

\begin{lstlisting}[caption={Type Universe},label={lst:type-universe}]
enum Primitive {
	TEXT;
	REAL;
	INTEGER;
	BOOLEAN;
}

abstract class Type {
  op String[1] serialize();
  op boolean[1] isNumeric();
	op String[1] toJavaType();
}

class PrimitiveType extends Type {
  attr Primitive[1] primitive;
}

class InvalidType extends Type {
  attr String[1] cause;
}
\end{lstlisting}

\begin{lstlisting}[caption={Expression Language},label={lst:expression-language}]
  abstract class Expression {
	op Type[1] type();
	op String[1] toHRN();
	op Symbol[*] symbolReferences();
	op String[1] toJava();
}

class TextLiteral extends Expression {
	attr String[1] value;
}

class RealLiteral extends Expression {
	attr double[1] value;
}

class IntegerLiteral extends Expression {
	attr int[1] value;
}

class BooleanLiteral extends Expression {
	attr boolean[1] value;
}

class SymbolExpression extends Expression {
    ref Symbol[1] symbol;
}

enum UnaryOp {
	LOGICAL_NOT;
	NEGATION;
}

class UnaryExpression extends Expression {
	attr UnaryOp[1] operator;
	val Expression[1] body;
}

enum BinaryOp {
	// numbers (of same type)
	ADDITION; // also allowed for text and vectors
	MULTIPLICATION;
	DIVISION;
	SUBTRACTION;
	POWER;
	MODULO;

	// inequalities
	GREATER_THAN;
	GREATER_THAN_EQUAL_TO;
	LESS_THAN;
	LESS_THAN_EQUAL_TO;
	
	// booleans
	LOGICAL_AND;
	LOGICAL_OR;
	LOGICAL_IMPLIES;
	
	// any
	EQUIVALENT;
	NOT_EQUIVALENT;
}

class BinaryExpression extends Expression {
  attr BinaryOp[1] operator;
  val Expression[2] exprs;
}

enum TertiaryOp {
  IF_THEN_ELSE;
}

class TertiaryExpression extends Expression {
  attr TertiaryOp[1] operator;
  val Expression[3] exprs;
}
\end{lstlisting}

\begin{lstlisting}[caption={Constraints and Critiques},label={lst:constraints-and-critiques}]
operation String withCalculator(c : Calculator): String {
    return c.name + ": " + self;
}

operation allUnique(c : Collection): Boolean {
    var asSet = c.asSet();
    return c.size() == asSet.size();
}

operation Collection hasDuplicates(): Boolean {
    return self.asSet().size() == self.size();
}

context Calculator {
    constraint NameLength {
        check: self.name.length() > 0
        message: "Calculator must have a name."
    }

    critique Description {
        check: self.description.length() > 0
        message: "It would be nice if you defined a human-readable description of your calculator.".withCalculator(self)
    }

    constraint UniqueSymbols {
        check: allUnique(self.symbols().name)
        message: "All symbols should have unique names.".withCalculator(self)
    }

    constraint AtLeast1Input {
        check: self.inputs().size() > 0
        message: "Each calculator should have at least 1 input.".withCalculator(self)
    }

    constraint AtLeast1Output {
        check: self.outputs().size() > 0
        message: "Each calculator should have at least 1 output.".withCalculator(self)
    }

    critique AllInputsDescribed {
        check: self.inputs().declaration.description.forAll(s|s.length() > 0)
        message: "Each input symbol should have a description for usability.".withCalculator(self)
    }

    critique AllOutputsDescribed {
        check: self.outputs().declaration.description.forAll(s|s.length() > 0)
        message: "Each output symbol should have a description for usability.".withCalculator(self)
    }

    constraint AllOutputsAssignedOnce {
        check: self.outputs().forAll(o|self.hasAssignmentStep(o))
        message: "Each output symbol should be assigned at least once in your calculation steps.".withCalculator(self)
    }

    constraint AllIntermediatesAssignedOnce {
        check: self.intermediates().forAll(o|self.hasAssignmentStep(o))
        message: "Each intermediate symbol should be assigned at least once in your calculation steps.".withCalculator(self)
    }

    constraint AllAssignmentsWellTyped {
        check: self.assignmentSteps().forAll(astep|astep.symbol.type.equiv(astep.body.type()))
        message: "Each assignment step must be well-typed.".withCalculator(self)
    }

    constraint AllTestCaseInputSymbolsAreInputs {
        check: self.testCases.forAll(testCase|testCase.assignments.forAll(asgn|asgn.symbol.declaration.kind==SymbolDeclarationKind#INPUT))
        message: "Test case inputs should only assign values to input variables".withCalculator(self)
    }

    constraint AllTestCaseInputExpressionsLiteral {
        check: self.testCases.forAll(testCase|testCase.assignments.forAll(asgn|asgn.body.symbolReferences().isEmpty()))
        message: "Test case inputs should not reference any symbol in their assignments.".withCalculator(self)
    }

    constraint AllTestCaseAssignAllInputs {
        // note: using '>=' here because (a) we already ensure that each symbol assigned is an input
        //       and that there are no duplicate assignments.
        check: self.testCases.forAll(testCase|testCase.assignments.symbol.size() >= self.inputs().size())
        message: "Test case inputs should assign a value to each input.".withCalculator(self)
    }

    constraint AllTestCaseInputsUnambiguous {
        check: self.testCases.forAll(testCase|testCase.assignments.symbol.hasDuplicates())
        message: "Test case inputs may not have ambiguous assignments for input symbols.".withCalculator(self)
    }

    constraint AllTestCaseAssertionsAreBooleanTyped {
        check: self.testCases.forAll(testCase|testCase.assertions.forAll(e|isBoolTy(e.type())))
        message: "Test case assertions must all be propositions (boolean-typed expressions)".withCalculator(self)
    }

    critique AllTestCaseAssertionsMeaningful {
        check: self.testCases.forAll(testCase|testCase.assertions.forAll(e|not e.symbolReferences().isEmpty()))
        message: "Each test case assertion should have at least 1 symbol reference, or else the check if superfluous".withCalculator(self)
    }

    constraint AllStepsDepsHaveValues {
        check: self.checkStepDependencies()
        message: "Each step's symbol dependencies must be satisfied before that step.".withCalculator(self)
    }

    constraint AllTestCasesSatisfied {
        guard: self.satisfiesAll("AllStepsDepsHaveValues", "AllTestCaseAssertionsAreBooleanTyped", "WellTyped", "AllIntermediatesAssignedOnce", "AllOutputsAssignedOnce")
        check: self.testCases.forAll(testCase|testCase.isSatisfied(self.steps))
        message: "Not all test cases are satisfied! Check algorithm!".withCalculator(self)
    }
}

context Expression {
    constraint WellTyped {
        check: self.isWellTyped()
        message: "Expression is ill-typed: " + self.type().serialize()
    }
}

context Symbol {
    constraint SymbolsNamed {
        check: Symbol.forAll(s|s.name.length() > 0)
        message: "All symbols must have a non-empty name"
    }

    constraint SymbolsNamedAppropriately {
        check: Symbol.forAll(s|s.name.matches("^[a-zA-Z]([a-zA-Z0-9_]+)?\$"))
        message: "All symbols must start with a letter and be followed by a sequence of letters, numbers or underscores."
    }
}
\end{lstlisting}

\end{document}
