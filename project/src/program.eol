// CALCULATOR

@cached
operation Calculator declarations(): Collection {
    return self.symbolDeclarations;
}

@cached
operation Calculator symbols(): Collection {
    return self.symbolDeclarations.symbol;
}

@cached
operation Calculator symbolsOfKind(k : Any): Collection {
    return self.declarations().select(d|d.kind=k).symbol;
}

@cached
operation Calculator inputs(): Collection {
    return self.symbolsOfKind(SymbolDeclarationKind#INPUT);
}

@cached
operation Calculator intermediates(): Collection {
    return self.symbolsOfKind(SymbolDeclarationKind#INTERMEDIATE);
}

@cached
operation Calculator outputs(): Collection {
    return self.symbolsOfKind(SymbolDeclarationKind#OUTPUT);
}

@cached
operation Calculator assignmentSteps(): Collection {
    return self.steps.selectByType(AssignmentStep);
}

@cached
operation Calculator hasAssignmentStep(s : Symbol): Boolean {
    return self.assignmentSteps().exists(astep|astep.symbol=s);
}

// STEPS

operation AssignmentStep toHRN(): String {
    return self.symbol.name + " = " + self.body.toHRN();
}

operation PrintStep toHRN(): String {
    return "debug: show " + self.symbol.name;
}

// TYPES

@cached
operation PrimitiveType serialize(): String {
	switch (self.primitive) {
		case Primitive#TEXT:
			return "Text";
		case Primitive#REAL:
			return "Real";
		case Primitive#INTEGER:
			return "Integer";
		case Primitive#BOOLEAN:
			return "Boolean";
	}
}

@cached
operation VectorType serialize(): String {
	return "Vector(" + self.valueType.serialize() + "," + self.length.asString() + ")";
}

operation PrimitiveType isNumeric(): Boolean {
	switch (self.primitive) {
		case Primitive#REAL:
			return true;
		case Primitive#INTEGER:
			return true;
		default:
			return false;
	}
}

operation VectorType isNumeric(): Boolean {
	return false;
}

operation typeEquiv(left : Type, right : Type): Boolean {
	return left.serialize() == right.serialize();
}

operation Type equiv(other : Type): Boolean {
	return typeEquiv(self, other);
}

operation Type isInvalid(): Boolean {
    return false;
}

operation InvalidType isInvalid(): Boolean {
    return true;
}

// EXPRESSIONS
operation primitiveType(p : Any): Type {
	var t = new PrimitiveType();
	t.primitive = p;
	return t;
}

@cached
operation TextLiteral type(): Type {
	// return primitiveType(Primitive#TEXT);
	var t = new PrimitiveType();
	t.primitive = Primitive#TEXT;
	return t;
}

@cached
operation RealLiteral type(): Type {
	return primitiveType(Primitive#REAL);
}

@cached
operation IntegerLiteral type(): Type {
	return primitiveType(Primitive#INTEGER);
}

@cached
operation BooleanLiteral type(): Type {
	return primitiveType(Primitive#BOOLEAN);
}

operation isBoolTy(t : Type): Boolean {
    var boolTy = primitiveType(Primitive#BOOLEAN);
    return boolTy.equiv(t);
}

operation isTextTy(t : Type): Boolean {
    var textTy = primitiveType(Primitive#TEXT);
    return textTy.equiv(t);
}

operation isNumericTy(t : Type): Boolean {
    var realTy = primitiveType(Primitive#REAL);
    var intTy = primitiveType(Primitive#INTEGER);
    if (realTy.equiv(t)) {
        return true;
    } else if (intTy.equiv(t)) {
        return true;
    }
    return false;
}

operation invalidTy(cause : String): InvalidType {
    var invTy = new InvalidType();
    invTy.cause = cause;
    return invTy;
}

operation InvalidType serialize(): String {
    return self.cause;
}

operation InvalidType isNumeric(): Boolean {
    return false;
}

operation isInvalid(t : Type): Boolean {
    return t.isInvalid();
}

operation Expression isWellTyped(): Boolean {
    return (not isInvalid(self.type()));
}

operation SymbolExpression type(): Type {
    return self.symbol.type;
}

@cached
operation UnaryExpression type(): Type {
    var bodyTy = self.body.type();
    if (isInvalid(bodyTy)) {
        return bodyTy;
    }
    
    switch (self.operator) {
        case UnaryOp#LOGICAL_NOT:
            if (isBoolTy(bodyTy)) {
                return bodyTy;
            } 
            return invalidTy("logical negation expects boolean operand");
        case UnaryOp#NEGATION:
            if (isNumericTy(bodyTy)) {
                return bodyTy;
            }
            return invalidTy("negation expects numeric operand");
    }
}

@cached
operation BinaryExpression type(): Type {
    var leftTy = self.exprs[0].type();
    if (isInvalid(leftTy)) {
        return leftTy;
    }
    
    var rightTy = self.exprs[1].type();
    if (isInvalid(rightTy)) {
        return rightTy;
    }
    
    switch (self.operator) {
        case BinaryOp#ADDITION:
            if (leftTy.equiv(rightTy) and (isNumericTy(leftTy) or isTextTy(leftTy))) {
                return leftTy;
            }
            return invalidTy("both operands of an addition/catenation must be numerics/text");
        case BinaryOp#MULTIPLICATION:
            continue;
        case BinaryOp#DIVISION:
            continue;
        case BinaryOp#SUBTRACTION:
            continue;
        case BinaryOp#POWER:
            if (leftTy.equiv(rightTy) and isNumericTy(leftTy)) {
                return leftTy;
            }
            return invalidTy("both operands of mul/sub/pow expected to be the same numeric type");
        case BinaryOp#LOGICAL_AND:
            continue;
        case BinaryOp#LOGICAL_OR:
            continue;
        case BinaryOp#LOGICAL_IMPLIES:
            if (isBoolTy(leftTy) and isBoolTy(rightTy)) {
                return leftTy;
            }
            return invalidTy("both operands of and/or/implies are expected to be boolean-typed");      
        case BinaryOp#EQUALITY:
            if (leftTy.equiv(rightTy)) {
                return primitiveType(Primitive#BOOLEAN);
            }
            return invalidTy("both operands of equality expected to be of the same type");
    }
}

operation TextLiteral toHRN(): String {
    return self.value;
}

operation IntegerLiteral toHRN(): String {
    return self.value.asString();
}

operation RealLiteral toHRN(): String {
    return self.value.asString();
}

operation BooleanLiteral toHRN(): String {
    return self.value.asString().toUpperCase();
}

operation SymbolExpression toHRN(): String {
    return self.symbol.name;
}

@cached
operation UnaryExpression toHRN(): String {
    var op = "";
    switch (self.operator) {
        case UnaryOp#LOGICAL_NOT:
            op = "¬";
        case UnaryOp#NEGATION:
            op = "-";
    }
    return op + " (" + self.body.toHRN() + ")";
}


@cached
operation BinaryExpression toHRN(): String {
    var left = self.exprs[0].toHRN();
    var right = self.exprs[1].toHRN();
    var op = "";

    switch (self.operator) {
        case BinaryOp#ADDITION:
            op = "+";
        case BinaryOp#MULTIPLICATION:
            op = "×";
        case BinaryOp#DIVISION:
            return "(" + left + ") / (" + right + ")";
        case BinaryOp#SUBTRACTION:
            op = "-";
        case BinaryOp#POWER:
            op = "^";
        case BinaryOp#LOGICAL_AND:
            op = "∧";
        case BinaryOp#LOGICAL_OR:
            op = "∨";
        case BinaryOp#LOGICAL_IMPLIES:
            op = "⇒";
        case BinaryOp#EQUALITY:
            op = "==";
    }

    return "(" + left + " " + op + " " + right + ")";
}
