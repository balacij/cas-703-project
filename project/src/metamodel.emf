@namespace(uri="calculator", prefix="c")
package calculator;

/* PROSPECTIVE CALCULATOR CODE EXAMPLE

calculator potato with
	constants
		x = 4 : Real m
		y = 10 : Real kg
	variables
		inputs
			n : Integer ~ Number of items
			a : Vector (Real m) n ~ Items
		intermediates
			b : Real m ~ Sum of items
		outputs
			c : Real m ~ Sum of items, doubled
	steps
		b = sum(a)
		c = 2 * a


COMMENTARY:
	1. constants are declared with values, translate to `public static final` 
		constants in Java
	2. inputs are declared with type signature and input message for users
	3. "Vector (Real m) n" is a complex type that we will need to be careful 
		with handling
	4. intermediate symbols are purely meant for internal calculations, with a 
		message for debugging
	5. outputs are declared with type signature and input message for users
	6. variable (inputs, outputs, intermediates) should all be of the same 
		metamodel but with a different enum 'kind'
	7. steps should be analyzed to make sure all outputs are somehow assigned a 
		value and that each step depends on expressions that were previously 
		assigned something

QUESTIONS:
	1. It looks like it will be very difficult to build a textual editor for 
		this. Should we just go for building a visual editor with Eugenia?
		Writing expressions in Eugenia might be odd however.
	
	2. Should we just export a calculator program in Java? Or should we perform
		the calculation ourselves? Personally, I tend towards the first because
		it sounds simpler, but it might be more appropriate to do the second. We
		could also do a hybrid of the two -- generate a Java program and run it
		from our own code automatically.

*/

class Calculator {
    attr String[1] name;
	attr String[1] description;

	// TODO: Each calculator should have a (i) list of symbol declarations
	// (which may or may not be 'constant'/'final'), (ii) list of input symbols,
	// (iii) list of output symbols, and (iv) list of statements that somehow
	// affect each output symbol and use each input symbol.

	// TODO: As of right now, the "name" of the calculator is the only "good"
	// part of this calculator metamodel. The symbols and expressions are here
	// for purely testing purposes. They should later be used by other
	// components instead.

    val Symbol[*] symbols;
    val Expression[*] exprs;
}

// TYPES
enum Primitive {
	TEXT;
	REAL;
	INTEGER;
	BOOLEAN;
}

abstract class Type {
	op String[1] serialize();
	op boolean[1] isNumeric();
}

class PrimitiveType extends Type {
	attr Primitive[1] primitive;
}

class VectorType extends Type {
	attr int[1] length;
	val Type[1] valueType;
}

class InvalidType extends Type {
    attr String[1] cause;
}

// EXPRESSIONS
abstract class Expression {
	op Type[1] type();
	op String[1] asJava();
}

class TextLiteral extends Expression {
	attr String[1] value;
}

class RealLiteral extends Expression {
	attr double[1] value;
}

class IntegerLiteral extends Expression {
	attr int[1] value;
}

class BooleanLiteral extends Expression {
	attr boolean[1] value;
}

class Symbol {
    id attr String[1] name;
    val Type[1] type;
}

class SymbolExpression extends Expression {
    ref Symbol[1] symbol;
}

// TODO: Need to add vector operations: dimension, magnitude
enum UnaryOp {
	LOGICAL_NOT;
	NEGATION;
}

class UnaryExpression extends Expression {
	attr UnaryOp[1] operator;
	val Expression[1] body;
}

// TODO: Need to add vector operations: dot, scale, add
enum BinaryOp {
	// numbers (of same type)
	ADDITION; // also allowed for text and vectors
	MULTIPLICATION;
	SUBTRACTION;
	POWER;
	
	// booleans
	LOGICAL_AND;
	LOGICAL_OR;
	LOGICAL_IMPLIES;
	
	// any
	EQUALITY;
}

class BinaryExpression extends Expression {
	attr BinaryOp[1] operator;
	val Expression[2] exprs;
}
