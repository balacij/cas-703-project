@namespace(uri="calculator", prefix="c")
package calculator;

/* PROSPECTIVE CALCULATOR CODE EXAMPLE

calculator potato with
	symbols
		constants
			x = 4 : Real m
			y = 10 : Real kg
		inputs
			n : Integer ~ Number of items
			a : Vector (Real m) n ~ Items
		intermediates
			b : Real m ~ Sum of items
		outputs
			c : Real m ~ Sum of items, doubled
	steps
		b = sum(a)
		c = 2 * a


COMMENTARY:
	1. constants are declared with values, translate to `public static final` 
		constants in Java
	2. inputs are declared with type signature and input message for users
	3. "Vector (Real m) n" is a complex type that we will need to be careful 
		with handling
	4. intermediate symbols are purely meant for internal calculations, with a 
		message for debugging
	5. outputs are declared with type signature and input message for users
	6. variable (inputs, outputs, intermediates) should all be of the same 
		metamodel but with a different enum 'kind'
	7. steps should be analyzed to make sure all outputs are somehow assigned a 
		value and that each step depends on expressions that were previously 
		assigned something

QUESTIONS:
	1. It looks like it will be very difficult to build a textual editor for 
		this. Should we just go for building a visual editor with Eugenia?
		Writing expressions in Eugenia might be odd however.
	
	2. Should we just export a calculator program in Java? Or should we perform
		the calculation ourselves? Personally, I tend towards the first because
		it sounds simpler, but it might be more appropriate to do the second. We
		could also do a hybrid of the two -- generate a Java program and run it
		from our own code automatically.

*/

abstract class Described {
	attr String[1] description = "";
}

class Calculator extends Described {
    attr String[1] name;
	val SymbolDeclaration[*] symbolDeclarations;
	val CalculationStep[*] steps;
}

enum SymbolDeclarationKind {
	INPUT;
	INTERMEDIATE;
	OUTPUT;
}

class SymbolDeclaration extends Described {
	attr SymbolDeclarationKind[1] kind;
	val Symbol[1] symbol;
}

abstract class CalculationStep extends Described {
	op String[1] toJava();
	op String[1] toHRN();
}

class AssignmentStep extends CalculationStep {
	ref Symbol[1] symbol; // LHS
	val Expression[1] body; // RHS
}

class PrintStep extends CalculationStep {
	attr String[+] preface;
	ref Symbol[1] symbol;
}

// TYPES
enum Primitive {
	TEXT;
	REAL;
	INTEGER;
	BOOLEAN;
}

abstract class Type {
	op String[1] serialize();
	op boolean[1] isNumeric();
}

class PrimitiveType extends Type {
	attr Primitive[1] primitive;
}

class VectorType extends Type {
	attr int[1] length;
	val Type[1] valueType;
}

class InvalidType extends Type {
    attr String[1] cause;
}

// EXPRESSIONS
abstract class Expression {
	op Type[1] type();
	op String[1] toHRN();
}

class TextLiteral extends Expression {
	attr String[1] value;
}

class RealLiteral extends Expression {
	attr double[1] value;
}

class IntegerLiteral extends Expression {
	attr int[1] value;
}

class BooleanLiteral extends Expression {
	attr boolean[1] value;
}

class Symbol {
    id attr String[1] name;
    val Type[1] type;
}

class SymbolExpression extends Expression {
    ref Symbol[1] symbol;
}

// TODO: Need to add vector operations: dimension, magnitude
enum UnaryOp {
	LOGICAL_NOT;
	NEGATION;
}

class UnaryExpression extends Expression {
	attr UnaryOp[1] operator;
	val Expression[1] body;
}

// TODO: Need to add vector operations: dot, scale, add
enum BinaryOp {
	// numbers (of same type)
	ADDITION; // also allowed for text and vectors
	MULTIPLICATION;
	SUBTRACTION;
	POWER;
	
	// booleans
	LOGICAL_AND;
	LOGICAL_OR;
	LOGICAL_IMPLIES;
	
	// any
	EQUALITY;
}

class BinaryExpression extends Expression {
	attr BinaryOp[1] operator;
	val Expression[2] exprs;
}
