// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

import "calculator"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Calculator returns Calculator:
	('Calculator' | 'calculator')
	name=EString
	description=EString
	('symbols' | 'Symbols')
	(symbolDeclarations+=SymbolDeclaration)+
	('steps' | 'Steps')
	(steps+=CalculationStep)+
	('testCases' | 'TestCases')
	(testCases+=TestCase)+;

CalculationStep returns CalculationStep:
	AssignmentStep | PrintStep;

Type returns Type:
	PrimitiveType;

EString returns ecore::EString:
	STRING | ID;

SymbolDeclaration returns SymbolDeclaration:
	kind=SymbolDeclarationKind symbol=Symbol ('~' description=EString)?;

TestCase returns TestCase:
	name=EString
	('for' | 'For') description=EString
	('inputs' | 'Inputs')
	(assignments+=AssignmentStep)*
	('assertions' | 'Assertions')
	(assertions+=Expression)*;

enum SymbolDeclarationKind returns SymbolDeclarationKind:
	INPUT='INPUT'
	| INTERMEDIATE='INTERMEDIATE'
	| OUTPUT='OUTPUT';

Symbol returns Symbol:
	name=EString
	':' type=Type;

PrimitiveType returns PrimitiveType:
	primitive=Primitive;

enum Primitive returns Primitive:
	TEXT='TEXT' | REAL='REAL' | INTEGER='INTEGER' | BOOLEAN='BOOLEAN';

EInt returns ecore::EInt:
	INT;

AssignmentStep returns AssignmentStep:
	symbol=[Symbol|EString]
	'=' body=Expression
	('~' description=EString)?;

PrintStep returns PrintStep:
	preface='print'
	'('
	symbol=[Symbol|EString]
	(',' preface=EString)?
	')'
	'~' description=EString;

TextLiteral returns TextLiteral:
	value=STRING;

RealLiteral returns RealLiteral:
	value=EDouble;

IntegerLiteral returns IntegerLiteral:
	value=EInt;

BooleanLiteral returns BooleanLiteral:
	value?=EBoolean;

SymbolExpression returns SymbolExpression:
	symbol=[Symbol|ID];

UnaryExpression returns UnaryExpression:
	operator=UnaryOp
	body=Expression;

Expression returns Expression:
	TextLiteral | RealLiteral | IntegerLiteral | BooleanLiteral | SymbolExpression | UnaryExpression | BinaryExpression
	| TertiaryExpression;

BinaryExpression returns BinaryExpression:
	'(' operator=BinaryOp exprs+=Expression exprs+=Expression ')';

TertiaryExpression returns TertiaryExpression:
	operator=TertiaryOp
	exprs+=Expression 'then' exprs+=Expression 'else' exprs+=Expression 'end';

EDouble returns ecore::EDouble:
	INT '.' INT (('E' | 'e') '-'? INT)?;

EBoolean returns ecore::EBoolean:
	'true' | 'false';

enum UnaryOp returns UnaryOp:
	LOGICAL_NOT='!' | NEGATION='-';

enum BinaryOp returns BinaryOp:
	ADDITION='+' | MULTIPLICATION='*' | DIVISION='/' | SUBTRACTION='-' | POWER='^' | MODULO='%' | GREATER_THAN='>' |
	GREATER_THAN_EQUAL_TO='>=' | LESS_THAN='<' | LESS_THAN_EQUAL_TO='<=' | LOGICAL_AND='&&' | LOGICAL_OR='||' |
	LOGICAL_IMPLIES='->' | EQUIVALENT='==' | NOT_EQUIVALENT='!=';

enum TertiaryOp returns TertiaryOp:
	IF_THEN_ELSE='if';
//BinaryExpression returns BinaryExpression:
//	Or
//;
//	
//Or returns BinaryExpression: 
//	exprs+=And ( "||" exprs+=And)*
//;
//
//And returns BinaryExpression: 
//	exprs+=LogicImplies ( "&&" exprs+=LogicImplies)*
//;
//
//
//LogicImplies returns BinaryExpression: 
//	exprs+=Equality ( "->" exprs+=Equality)*
//;
//
//Equality returns BinaryExpression: 
//	exprs+=Comparison ( ("=="|"!=") exprs+=Comparison)*
//;
//
//
//Comparison returns BinaryExpression: 
//	exprs+=Modulus ( ("<"|">"|"<="|">=") exprs+=Modulus)*
//;
//
//Modulus returns BinaryExpression: 
//	exprs+=AddSub ( "%" exprs+=AddSub)*
//;
//
//
//AddSub returns BinaryExpression: 
//	exprs+=MulDiv ( ("+"|"-") exprs+=MulDiv)*
//;
//
//MulDiv returns BinaryExpression: 
//	exprs+=Power ( ("*"|"/") exprs+=Power)*
//;
//
//
//Power returns BinaryExpression: 
//	exprs+=Primary ( "^" exprs+=Primary)*
//;
//
//Primary returns Expression:
//	'(' Expression ')' |
//	UnaryExpression |
//	SymbolExpression | 
//	TextLiteral | RealLiteral | IntegerLiteral | BooleanLiteral
//	
//;
//BinaryExpression:
//	Or
//;
//	
//Or returns BinaryExpression: 
//	exprs+=And ( operator=OrOp exprs+=And)*
//;
//
//And returns BinaryExpression: 
//	exprs+=LogicImplies ( operator=AndOp exprs+=LogicImplies)*
//;
//
//
//LogicImplies returns BinaryExpression: 
//	exprs+=Equality ( operator=LogicImpliesOp exprs+=Equality)*
//;
//
//Equality returns BinaryExpression: 
//	exprs+=Comparison ( operator=EqualityOp exprs+=Comparison)*
//;
//
//
//Comparison returns BinaryExpression: 
//	exprs+=Modulus ( operator=ComparisonOp exprs+=Modulus)*
//;
//
//Modulus returns BinaryExpression: 
//	exprs+=AddSub ( operator=ModulusOp exprs+=AddSub)*
//;
//
//
//AddSub returns BinaryExpression: 
//	exprs+=MulDiv ( operator=AddSubOp exprs+=MulDiv)*
//;
//
//MulDiv returns BinaryExpression: 
//	exprs+=Power ( operator=MulDivOp exprs+=Power)*
//;
//
//
//Power returns BinaryExpression: 
//	exprs+=Primary ( operator=PowerOp exprs+=Primary)*
//;
//
//Primary returns Expression:
//	'(' Expression ')' |
//	SymbolExpression | 
//	TextLiteral | RealLiteral | IntegerLiteral | BooleanLiteral
//	
//;
//enum OrOp returns BinaryOp:
//	LOGICAL_OR = '||'
//;
//
//enum AndOp returns BinaryOp:
//	LOGICAL_AND = '&&'
//;
//
//enum LogicImpliesOp returns BinaryOp:
//	LOGICAL_IMPLIES = '->'
//;
//
//
//enum EqualityOp returns BinaryOp:
//	EQUIVALENT = '==' | NOT_EQUIVALENT = '!='
//;
//
//
//enum ComparisonOp returns BinaryOp:
//	GREATER_THAN = '>' | GREATER_THAN_EQUAL_TO = '>=' | LESS_THAN = '<' | LESS_THAN_EQUAL_TO = '<='
//;
//
//enum ModulusOp returns BinaryOp:
//	MODULO = '%'
//;
//
//enum AddSubOp returns BinaryOp:
//	ADDITION = '+' | SUBTRACTION = '-'
//;
//
//enum MulDivOp returns BinaryOp:
//	MULTIPLICATION = '*' | DIVISION = '/'
//;
//
//enum PowerOp returns BinaryOp:
//	POWER = '^' 
//;
